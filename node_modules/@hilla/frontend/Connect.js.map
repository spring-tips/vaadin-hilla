{"version":3,"file":"Connect.js","sourceRoot":"","sources":["src/Connect.ts"],"names":[],"mappings":"AAAA,yCAAyC;AACzC,OAAO,EAAE,mBAAmB,EAAE,eAAe,EAAE,MAAM,yBAAyB,CAAC;AAC/E,OAAO,EAAE,qCAAqC,EAAE,MAAM,gBAAgB,CAAC;AAEvE,MAAM,IAAI,GAAG,MAAa,CAAC;AAC3B,sBAAsB;AACtB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,IAAI,EAAE,CAAC;AAChC,IAAI,CAAC,MAAM,CAAC,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,aAAa,IAAI,EAAE,CAAC;AAC5D,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC;IAC7B,EAAE,EAAE,UAAU;CACf,CAAC,CAAC;AAEH;;;GAGG;AACH,MAAM,OAAO,aAAc,SAAQ,KAAK;IAYtC;;;;OAIG;IACH,YAAmB,OAAe,EAAE,IAAa,EAAE,MAAY;QAC7D,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;CACF;AAED;;;;GAIG;AACH,MAAM,OAAO,uBAAwB,SAAQ,aAAa;IAWxD;;;;OAIG;IACH,YAAmB,OAAe,EAAE,mBAA0C,EAAE,IAAa;QAC3F,KAAK,CAAC,OAAO,EAAE,IAAI,EAAE,mBAAmB,CAAC,CAAC;QAC1C,IAAI,CAAC,sBAAsB,GAAG,OAAO,CAAC;QACtC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,mBAAmB,GAAG,mBAAmB,CAAC;IACjD,CAAC;CACF;AAED;;GAEG;AACH,MAAM,OAAO,qBAAsB,SAAQ,KAAK;IAM9C;;;OAGG;IACH,YAAmB,OAAe,EAAE,QAAkB;QACpD,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC3B,CAAC;CACF;AASD,MAAM,qBAAqB,GAAG,CAAC,SAA+B,EAAE,EAAE;IAChE,IAAI,SAAS,CAAC,mBAAmB,EAAE;QACjC,MAAM,IAAI,uBAAuB,CAAC,SAAS,CAAC,OAAO,EAAE,SAAS,CAAC,mBAAmB,EAAE,SAAS,CAAC,IAAI,CAAC,CAAC;KACrG;SAAM;QACL,MAAM,IAAI,aAAa,CAAC,SAAS,CAAC,OAAO,EAAE,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,MAAM,CAAC,CAAC;KAC9E;AACH,CAAC,CAAC;AAEF;;;;GAIG;AACH,MAAM,kBAAkB,GAAG,KAAK,EAAE,QAAkB,EAAiB,EAAE;IACrE,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE;QAChB,MAAM,SAAS,GAAG,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAC;QACxC,IAAI,SAAsC,CAAC;QAC3C,IAAI;YACF,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;SACnC;QAAC,OAAO,OAAO,EAAE;YAChB,aAAa;YACb,SAAS,GAAG,IAAI,CAAC;SAClB;QAED,IAAI,SAAS,KAAK,IAAI,EAAE;YACtB,qBAAqB,CAAC,SAAS,CAAC,CAAC;SAClC;aAAM,IAAI,SAAS,KAAK,IAAI,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;YACrD,MAAM,IAAI,qBAAqB,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;SACtD;aAAM;YACL,MAAM,IAAI,aAAa,CAAC,uCAAuC,QAAQ,CAAC,MAAM,IAAI,QAAQ,CAAC,UAAU,EAAE,CAAC,CAAC;SAC1G;KACF;AACH,CAAC,CAAC;AAEF;;GAEG;AACH,MAAM,OAAO,mBAAmB;IAW9B;;;OAGG;IACH,YAAmB,OAAe,EAAE,aAAsB;QACxD,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;IACrC,CAAC;CACF;AA2ED,SAAS,YAAY;;IACnB,OAAO,CAAA,MAAA,MAAA,IAAI,CAAC,MAAM,CAAC,IAAI,0CAAE,OAAO,0CAAE,UAAU,MAAK,SAAS,CAAC;AAC7D,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH,MAAM,OAAO,aAAa;IAWxB;;OAEG;IACH,YAAmB,UAAgC,EAAE;QAbrD;;WAEG;QACI,WAAM,GAAG,UAAU,CAAC;QAE3B;;WAEG;QACI,gBAAW,GAAiB,EAAE,CAAC;QAMpC,IAAI,OAAO,CAAC,MAAM,EAAE;YAClB,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;SAC9B;QAED,IAAI,OAAO,CAAC,WAAW,EAAE;YACvB,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC;SACxC;QAED,kCAAkC;QAClC,mBAAmB,CAAC,MAAM,EAAE,CAAC;QAE7B,wFAAwF;QACxF,wEAAwE;QACxE,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,GAAG,EAAE;YACnC,IAAI,CAAC,YAAY,EAAE,EAAE;gBACnB,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,KAAK,GAAG,eAAe,CAAC,SAAS,CAAC;aAC/D;QACH,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE;YACpC,IAAI,CAAC,YAAY,EAAE,EAAE;gBACnB,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,KAAK,GAAG,eAAe,CAAC,eAAe,CAAC;aACrE;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;;;;OAUG;IACI,KAAK,CAAC,IAAI,CAAC,QAAgB,EAAE,MAAc,EAAE,MAAY;QAC9D,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;YACxB,MAAM,IAAI,SAAS,CAAC,sCAAsC,SAAS,CAAC,MAAM,EAAE,CAAC,CAAC;SAC/E;QAED,MAAM,WAAW,GAAG,qCAAqC,CAAC,QAAQ,CAAC,CAAC;QACpE,MAAM,OAAO,GAA2B;YACtC,MAAM,EAAE,kBAAkB;YAC1B,cAAc,EAAE,kBAAkB;YAClC,GAAG,WAAW;SACf,CAAC;QAEF,oEAAoE;QACpE,MAAM,gBAAgB,GAAG,CAAC,GAA4B,EAA2B,EAAE,CACjF,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,QAAQ,EAAE,EAAE;YACzC,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,SAAS,EAAE;gBAChC,IAAI,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC;aACvB;YAED,OAAO,IAAI,CAAC;QACd,CAAC,EAAE,GAAG,CAAC,CAAC;QAEV,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,GAAG,IAAI,CAAC,MAAM,IAAI,QAAQ,IAAI,MAAM,EAAE,EAAE;YAClE,MAAM,EAAE,MAAM;YACd,OAAO;YACP,IAAI,EAAE,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS;SAClF,CAAC,CAAC;QAEH,wEAAwE;QACxE,wBAAwB;QACxB,MAAM,cAAc,GAAsB;YACxC,QAAQ;YACR,MAAM;YACN,MAAM;YACN,OAAO;SACR,CAAC;QAEF,yEAAyE;QACzE,0EAA0E;QAC1E,qEAAqE;QACrE,kCAAkC;QAClC,MAAM,yBAAyB,GAAe,KAAK,EACjD,OAA0B,EAC1B,IAAoB,EACD,EAAE;YACrB,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,CAAC;YACrC,MAAM,kBAAkB,CAAC,QAAQ,CAAC,CAAC;YACnC,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAC;YACnC,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,KAAU,EAAE,EAAE,CAAC,CAAC,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;QACnF,CAAC,CAAC;QAEF,4DAA4D;QAC5D,uEAAuE;QACvE,sDAAsD;QACtD,MAAM,SAAS,GAAmB,KAAK,EAAE,OAA0B,EAAqB,EAAE;YACxF,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;YAC7C,OAAO,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC;iBAC1B,IAAI,CAAC,CAAC,QAAQ,EAAE,EAAE;gBACjB,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,eAAe,EAAE,CAAC;gBAC9C,OAAO,QAAQ,CAAC;YAClB,CAAC,CAAC;iBACD,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;gBACf,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,EAAE,CAAC;gBAC5C,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAC/B,CAAC,CAAC,CAAC;QACP,CAAC,CAAC;QAEF,qDAAqD;QACrD,2BAA2B;QAC3B,MAAM,WAAW,GAAG,CAAC,yBAAuC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAEvF,0DAA0D;QAC1D,MAAM,KAAK,GAAG,WAAW,CAAC,WAAW,CACnC,CAAC,IAAoB,EAAE,UAAsB,EAAE,EAAE;YAC/C,oEAAoE;YACpE,wEAAwE;YACxE,uBAAuB;YACvB,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;gBAClB,IAAI,OAAO,UAAU,KAAK,UAAU,EAAE;oBACpC,OAAO,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;iBAClC;gBACD,OAAQ,UAA8B,CAAC,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;YAC/D,CAAC,CAAmB,CAAC;QACvB,CAAC;QACD,0DAA0D;QAC1D,SAAS,CACV,CAAC;QAEF,qDAAqD;QACrD,OAAO,KAAK,CAAC,cAAc,CAAC,CAAC;IAC/B,CAAC;CACF","sourcesContent":["/* eslint-disable max-classes-per-file */\nimport { ConnectionIndicator, ConnectionState } from '@vaadin/common-frontend';\nimport { getCsrfTokenHeadersForEndpointRequest } from './CsrfUtils.js';\n\nconst $wnd = window as any;\n/* c8 ignore next 2 */\n$wnd.Vaadin = $wnd.Vaadin || {};\n$wnd.Vaadin.registrations = $wnd.Vaadin.registrations || [];\n$wnd.Vaadin.registrations.push({\n  is: 'endpoint',\n});\n\n/**\n * An exception that gets thrown when the Vaadin backend responds\n * with not ok status.\n */\nexport class EndpointError extends Error {\n  /**\n   * The optional name of the exception that was thrown on a backend\n   */\n  public type?: string;\n\n  /**\n   * The optional detail object, containing additional information sent\n   * from a backend\n   */\n  public detail?: any;\n\n  /**\n   * @param message the `message` property value\n   * @param type the `type` property value\n   * @param detail the `detail` property value\n   */\n  public constructor(message: string, type?: string, detail?: any) {\n    super(message);\n    this.type = type;\n    this.detail = detail;\n  }\n}\n\n/**\n * An exception that gets thrown if Vaadin endpoint responds\n * with non-ok status and provides additional info\n * on the validation errors occurred.\n */\nexport class EndpointValidationError extends EndpointError {\n  /**\n   * An original validation error message.\n   */\n  public validationErrorMessage: string;\n\n  /**\n   * An array of the validation errors.\n   */\n  public validationErrorData: ValidationErrorData[];\n\n  /**\n   * @param message the `message` property value\n   * @param validationErrorData the `validationErrorData` property value\n   * @param type the `type` property value\n   */\n  public constructor(message: string, validationErrorData: ValidationErrorData[], type?: string) {\n    super(message, type, validationErrorData);\n    this.validationErrorMessage = message;\n    this.detail = null;\n    this.validationErrorData = validationErrorData;\n  }\n}\n\n/**\n * An exception that gets thrown for unexpected HTTP response.\n */\nexport class EndpointResponseError extends Error {\n  /**\n   * The optional response object, containing the HTTP response error\n   */\n  public response: Response;\n\n  /**\n   * @param message the `message` property value\n   * @param response the `response` property value\n   */\n  public constructor(message: string, response: Response) {\n    super(message);\n    this.response = response;\n  }\n}\n\ninterface ConnectExceptionData {\n  message: string;\n  type: string;\n  detail?: any;\n  validationErrorData?: ValidationErrorData[];\n}\n\nconst throwConnectException = (errorJson: ConnectExceptionData) => {\n  if (errorJson.validationErrorData) {\n    throw new EndpointValidationError(errorJson.message, errorJson.validationErrorData, errorJson.type);\n  } else {\n    throw new EndpointError(errorJson.message, errorJson.type, errorJson.detail);\n  }\n};\n\n/**\n * Throws a TypeError if the response is not 200 OK.\n * @param response The response to assert.\n * @ignore\n */\nconst assertResponseIsOk = async (response: Response): Promise<void> => {\n  if (!response.ok) {\n    const errorText = await response.text();\n    let errorJson: ConnectExceptionData | null;\n    try {\n      errorJson = JSON.parse(errorText);\n    } catch (ignored) {\n      // not a json\n      errorJson = null;\n    }\n\n    if (errorJson !== null) {\n      throwConnectException(errorJson);\n    } else if (errorText !== null && errorText.length > 0) {\n      throw new EndpointResponseError(errorText, response);\n    } else {\n      throw new EndpointError(`expected \"200 OK\" response, but got ${response.status} ${response.statusText}`);\n    }\n  }\n};\n\n/**\n * An object, containing all data for the particular validation error.\n */\nexport class ValidationErrorData {\n  /**\n   * The validation error message.\n   */\n  public message: string;\n\n  /**\n   * The parameter name that caused the validation error.\n   */\n  public parameterName?: string;\n\n  /**\n   * @param message the `message` property value\n   * @param parameterName the `parameterName` property value\n   */\n  public constructor(message: string, parameterName?: string) {\n    this.message = message;\n    this.parameterName = parameterName;\n  }\n}\n\n/**\n * The `ConnectClient` constructor options.\n */\nexport interface ConnectClientOptions {\n  /**\n   * The `prefix` property value.\n   */\n  prefix?: string;\n\n  /**\n   * The `middlewares` property value.\n   */\n  middlewares?: Middleware[];\n}\n\nexport interface EndpointCallMetaInfo {\n  /**\n   * The endpoint name.\n   */\n  endpoint: string;\n\n  /**\n   * The method name to call on in the endpoint class.\n   */\n  method: string;\n\n  /**\n   * Optional object with method call arguments.\n   */\n  params?: any;\n}\n\n/**\n * An object with the call arguments and the related Request instance.\n * See also {@link ConnectClient.call | the call() method in ConnectClient}.\n */\nexport interface MiddlewareContext extends EndpointCallMetaInfo {\n  /**\n   * The Fetch API Request object reflecting the other properties.\n   */\n  request: Request;\n}\n\n/**\n * An async middleware callback that invokes the next middleware in the chain\n * or makes the actual request.\n * @param context The information about the call and request\n */\nexport type MiddlewareNext = (context: MiddlewareContext) => Promise<Response> | Response;\n\n/**\n * An interface that allows defining a middleware as a class.\n */\nexport interface MiddlewareClass {\n  /**\n   * @param context The information about the call and request\n   * @param next Invokes the next in the call chain\n   */\n  invoke(context: MiddlewareContext, next: MiddlewareNext): Promise<Response> | Response;\n}\n\n/**\n * An async callback function that can intercept the request and response\n * of a call.\n */\ntype MiddlewareFunction = (context: MiddlewareContext, next: MiddlewareNext) => Promise<Response> | Response;\n\n/**\n * An async callback that can intercept the request and response\n * of a call, could be either a function or a class.\n */\nexport type Middleware = MiddlewareClass | MiddlewareFunction;\n\nfunction isFlowLoaded(): boolean {\n  return $wnd.Vaadin.Flow?.clients?.TypeScript !== undefined;\n}\n\n/**\n * Hilla Connect client class is a low-level network calling utility. It stores\n * a prefix and facilitates remote calls to endpoint class methods\n * on the Hilla backend.\n *\n * Example usage:\n *\n * ```js\n * const client = new ConnectClient();\n * const responseData = await client.call('MyEndpoint', 'myMethod');\n * ```\n *\n * ### Prefix\n *\n * The client supports an `prefix` constructor option:\n * ```js\n * const client = new ConnectClient({prefix: '/my-connect-prefix'});\n * ```\n *\n * The default prefix is '/connect'.\n *\n */\nexport class ConnectClient {\n  /**\n   * The Hilla endpoint prefix\n   */\n  public prefix = '/connect';\n\n  /**\n   * The array of middlewares that are invoked during a call.\n   */\n  public middlewares: Middleware[] = [];\n\n  /**\n   * @param options Constructor options.\n   */\n  public constructor(options: ConnectClientOptions = {}) {\n    if (options.prefix) {\n      this.prefix = options.prefix;\n    }\n\n    if (options.middlewares) {\n      this.middlewares = options.middlewares;\n    }\n\n    // add connection indicator to DOM\n    ConnectionIndicator.create();\n\n    // Listen to browser online/offline events and update the loading indicator accordingly.\n    // Note: if Flow.ts is loaded, it instead handles the state transitions.\n    $wnd.addEventListener('online', () => {\n      if (!isFlowLoaded()) {\n        $wnd.Vaadin.connectionState.state = ConnectionState.CONNECTED;\n      }\n    });\n    $wnd.addEventListener('offline', () => {\n      if (!isFlowLoaded()) {\n        $wnd.Vaadin.connectionState.state = ConnectionState.CONNECTION_LOST;\n      }\n    });\n  }\n\n  /**\n   * Makes a JSON HTTP request to the `${prefix}/${endpoint}/${method}` URL,\n   * optionally supplying the provided params as a JSON request body,\n   * and asynchronously returns the parsed JSON response data.\n   *\n   * @param endpoint Endpoint name.\n   * @param method Method name to call in the endpoint class.\n   * @param params Optional object to be send in JSON request body.\n   * @param options Optional client options for this call.\n   * @returns {} Decoded JSON response data.\n   */\n  public async call(endpoint: string, method: string, params?: any): Promise<any> {\n    if (arguments.length < 2) {\n      throw new TypeError(`2 arguments required, but got only ${arguments.length}`);\n    }\n\n    const csrfHeaders = getCsrfTokenHeadersForEndpointRequest(document);\n    const headers: Record<string, string> = {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      ...csrfHeaders,\n    };\n\n    // helper to keep the undefined value in object after JSON.stringify\n    const nullForUndefined = (obj: Record<string, unknown>): Record<string, unknown> =>\n      Object.keys(obj).reduce((_obj, property) => {\n        if (_obj[property] === undefined) {\n          _obj[property] = null;\n        }\n\n        return _obj;\n      }, obj);\n\n    const request = new Request(`${this.prefix}/${endpoint}/${method}`, {\n      method: 'POST',\n      headers,\n      body: params !== undefined ? JSON.stringify(nullForUndefined(params)) : undefined,\n    });\n\n    // The middleware `context`, includes the call arguments and the request\n    // constructed from them\n    const initialContext: MiddlewareContext = {\n      endpoint,\n      method,\n      params,\n      request,\n    };\n\n    // The internal middleware to assert and parse the response. The internal\n    // response handling should come last after the other middlewares are done\n    // with processing the response. That is why this middleware is first\n    // in the final middlewares array.\n    const responseHandlerMiddleware: Middleware = async (\n      context: MiddlewareContext,\n      next: MiddlewareNext,\n    ): Promise<Response> => {\n      const response = await next(context);\n      await assertResponseIsOk(response);\n      const text = await response.text();\n      return JSON.parse(text, (_, value: any) => (value === null ? undefined : value));\n    };\n\n    // The actual fetch call itself is expressed as a middleware\n    // chain item for our convenience. Always having an ending of the chain\n    // this way makes the folding down below more concise.\n    const fetchNext: MiddlewareNext = async (context: MiddlewareContext): Promise<Response> => {\n      $wnd.Vaadin.connectionState.loadingStarted();\n      return fetch(context.request)\n        .then((response) => {\n          $wnd.Vaadin.connectionState.loadingFinished();\n          return response;\n        })\n        .catch((error) => {\n          $wnd.Vaadin.connectionState.loadingFailed();\n          return Promise.reject(error);\n        });\n    };\n\n    // Assemble the final middlewares array from internal\n    // and external middlewares\n    const middlewares = [responseHandlerMiddleware as Middleware].concat(this.middlewares);\n\n    // Fold the final middlewares array into a single function\n    const chain = middlewares.reduceRight(\n      (next: MiddlewareNext, middleware: Middleware) => {\n        // Compose and return the new chain step, that takes the context and\n        // invokes the current middleware with the context and the further chain\n        // as the next argument\n        return ((context) => {\n          if (typeof middleware === 'function') {\n            return middleware(context, next);\n          }\n          return (middleware as MiddlewareClass).invoke(context, next);\n        }) as MiddlewareNext;\n      },\n      // Initialize reduceRight the accumulator with `fetchNext`\n      fetchNext,\n    );\n\n    // Invoke all the folded async middlewares and return\n    return chain(initialContext);\n  }\n}\n"]}